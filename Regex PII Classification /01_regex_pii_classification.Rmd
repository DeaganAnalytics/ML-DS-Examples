---
title: "Regex Classification: Example"
output: html_document
---

# Load packages and functions
```{r setup, include=FALSE}
library(stringr)
library(dplyr)
library(tidyr)
library(purrr)
library(tibble)
library(DBI)

source("read_sql.R") # see https://github.com/DeaganAnalytics/Personal-Automation/blob/main/R/Functions/read_sql.R
source("clean_df.R") # see https://github.com/DeaganAnalytics/Personal-Automation/blob/main/R/Functions/clean_df.R

folder_path <- "C:/Git/ML-DS-Examples/Regex PII Classification/table_samples"
```

# Import data
```{r}
column_names <- read_sql(con_name, "information_schema.sql", folder = "local") # see https://github.com/DeaganAnalytics/Personal-Automation/blob/main/R/Functions/server_connection.R for con_name
```

# Regex on column names
```{r}
# Clean column names data frame
columns_df <- column_names %>% 
  clean_df() %>%
  mutate(table = paste(table_schema, table_name, sep = ".")) %>%
  select(table, column_name, data_type)

# Define regex patterns to identify column names by category; all patterns are case-insensitive
patterns <- list(
  # ══════════════════════════════════════
  #           NAMES
  # ══════════════════════════════════════
  
  # ──────── Names ────────
  # ── Matches exact column names commonly used for names (strict match)
  names_exact = "(?i)^(firstname|fullname|lastname||middlename|nickname|preferredname)$", 
  
  # ── Matches columns containing name-related substrings (excludes terms like 'exact', 'partial', etc.)
  names_partial = "(?i)^(?!.*(exact|partial|required)).*(firstname|fullname|middlename|preferredname|username)",
  
  # ══════════════════════════════════════
  #           ADDRESSES
  # ══════════════════════════════════════
  
  # ──────── Address ────────
  # ── Matches columns containing "address" (anywhere in the name); excludes if certain disqualifying terms are present
  address = "(?i)^(?!.*(email|fax|flag).*address.*",

  # ──────── Post Code ────────
  # ── Matches columns ending in "postcode" or "postalcode" (optionally with prefix/underscores); excludes if "flag" is present
  postcode = "(?i)^(?!.*flag)(\\w+_?)?post(?:al)?_?code$", 
  
  # ──────── City ────────
  # ── Contains the word "city" or "_city"
  city = "(?i)(^|[^a-zA-Z0-9])_?city([^a-zA-Z0-9]|$)",
  
  # ──────── Latitude / Longitude ────────
  # Matches columns containing "latitude" or "longitude" anywhere in the name
  latitude_longitude = "(?i).*(latitude|longitude).*",
  
  # ══════════════════════════════════════
  #           PHONE & EMAIL
  # ══════════════════════════════════════
  
  # ──────── Phone Number ────────
  # ── Matches columns containing common phone-related terms (e.g. mobilephone, contactphone); excludes disqualifiers like 'code' or 'flag'
  phone_number = "(?i)^(?!.*(code|flag|name)).*(businessphone|businessmobile|contactphone|homephone|mobilephone|phonenumber|telephone).*",

  # ──────── Email Address ────────
  # ── Matches columns with common email-related terms; excludes disqualifiers like 'flag'
  emails = "(?i)^(?!.*(flag)).*(CCEmail|emailaddress|email_recipient).*",
  
  # ══════════════════════════════════════
  #           FINANCIAL DETAILS
  # ══════════════════════════════════════
  
  # ──────── Bank Account Number ────────
  # ── Matches common bank account number column names (e.g. bank_acct_num, bankaccountnumber)
  bank_account = "(?i).*(bank_acct_num|bankacctnum).*",
  
  # ──────── Bank Name ────────
  # ── Matches the word "bankname"
  bank_name = "(?i)bankname",
  
  # ──────── BSB Number ────────
  # ── Matches columns containing "bsb"; excludes those with "id" to avoid false positives like IDs
  bsb = "(?i)^(?!.*id).*bsb.*",
  
  # ──────── Card Expiry ────────
  # ── Matches columns containing both "card" and "expiry" anywhere in the name
  card_expiry = "(?i)(?=.*card)(?=.*expiry).*",
  
  # ──────── Card Number ────────
  # ── Matches column names containing "cardnumber"
  card_number = "(?i).*cardnumber*",
  
  # ══════════════════════════════════════
  #           BUSINESS DETAILS
  # ══════════════════════════════════════  
  
  # ──────── ABN ────────
  # ── Matches exactly "abn"
  abn = "(?i)^abn$",
  
  # ──────── ACN ────────
  # ── Matches exactly "acn"
  acn = "(?i)^acn$",

  # ══════════════════════════════════════
  #           OTHER PII
  # ══════════════════════════════════════
  
  # ──────── Gender ────────
  # ── Matches columns containing "gender" anywhere in the name
  gender = "(?i).*gender.*",
  
  # ──────── Date of Birth ────────
  # ── Matches columns containing both "birth" and "date" anywhere in the name
  birthday = "(?i)(?=.*birth)(?=.*date)"
)

# Use mutate + across to create new logical columns for each pattern
col_name_matches <- columns_df %>%
  mutate(
    # ── Names
    names_exact = str_detect(column_name, patterns$names_exact),
    names_partial = str_detect(column_name, patterns$names_partial),
    
    # ── Addresses
    address = str_detect(column_name, patterns$address),
    postcode = str_detect(column_name, patterns$postcode),
    city = str_detect(column_name, patterns$city),
    latitude_longitude = str_detect(column_name, patterns$latitude_longitude),
    
    # ── Phone & Emails
    phone_number = str_detect(column_name, patterns$phone_number),
    emails = str_detect(column_name, patterns$emails),
    
    # ── Financial Details
    bsb = str_detect(column_name, patterns$bsb),
    bank_account = str_detect(column_name, patterns$bank_account),
    bank_name = str_detect(column_name, patterns$bank_name),
    card_number = str_detect(column_name, patterns$card_number),
    card_expiry = str_detect(column_name, patterns$card_expiry),
    
    # ── Businesses
    abn = str_detect(column_name, patterns$abn),
    acn = str_detect(column_name, patterns$acn),
    
    # ── Other PII
    gender = str_detect(column_name, patterns$gender),
    birthday = str_detect(column_name, patterns$birthday),
    
    # ── Combine names flags: TRUE if either exact or contains matches
    names = names_exact | names_partial,
    addresses = address | postcode | city | latitude_longitude,
    financial_details = bsb | bank_account | bank_name | card_number | card_expiry,
    business = abn | acn
  ) %>% 
  mutate(column_matched = if_any(4:ncol(.), ~ .x)) %>% 
  relocate(column_matched, .after = data_type) %>% 
  select(table, column_name, data_type, column_matched, names, addresses, emails, phone_number, financial_details, business, gender, birthday)
```

# Get sample data from each table - eval = FALSE as this only needs to be run once, and takes quite a while
```{r, eval = FALSE}
source("C:/Git/ML-DS-Examples/Regex PII Classification/02_get_sample_data.R")
```

# Load rds files
```{r}
# List all .rds files in the folder, get full paths
files <- list.files(folder_path, pattern = "\\.rds$", full.names = TRUE)

# Read each RDS file into a data frame, add a source_table column with the filename (without extension)
all_samples <- lapply(files, function(f) {
  df <- readRDS(f)
  df$source_table <- sub("_", ".", tools::file_path_sans_ext(basename(f))) # filename without extension
  return(df)
})

# Combine all data frames into one big data frame
combined_samples <- bind_rows(all_samples)

# Split combined data back into a list of data frames, one per source_table (filename)
samples_by_table <- split(combined_samples, combined_samples$source_table)

# Define regex patterns to look for in string columns
patterns <- list(
  # ── Addresses
  # Matches Australian state abbreviation followed by a 4-digit postcode, with at least one space in between
  state_postcode = "(?i)\\b(NSW|QLD|TAS|VIC|ACT|WA|NT|SA)\\b\\s+\\d{4}",
  
  # Matches the word "lot", "lt", or "unit" at the start of a string or after a space, followed by at least one space
  lots_units = "(?i)(^|\\s)(lot|lt|unit)\\s+",
  
  # Matches common street suffixes (e.g., "St", "Road", "Ave"), surrounded by word boundaries or spaces
  streets = "(?i)(^|\\s)(av|ave|avenue|boulevard|blvd|cres|cr|ct|dr|drive|hwy|parade|pde|pl|place|rd|road|st|street|tce|terrace)(\\s|$)",
  
  # ── Phone numbers
  # Matches Australian phone numbers in the format "+61 123 456 789"
  mobile_number_spacing = "(?i)\\+61\\s\\d{3}\\s\\d{3}\\s\\d{3}",
  # Java 8: (?i)\+61\s\d{3}\s\d{3}\s\d{3}
  
  # Matches Australian landline numbers in the format "(02) 1234 5678" or "1234 5678"
  phone_number_spacing = "(\\(0[2-478]\\)\\s\\d{4}\\s\\d{4})|(\\d{4}\\s\\d{4})",
  # Java 8: (\(0[2-478]\)\s\d{4}\s\d{4})|(\d{4}\s\d{4})
  
  # ── Emails
  # Matches standard email addresses (e.g. user@example.com)
  email = "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b",
  # Java 8: ^[a-zA-Z0-9._%\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,6}$
  
  # ── Finance data
  # Matches a pattern of 6 digits, followed by three literal dots, then 3 digits (e.g., "123456...789")
  masked_credit_card = "\\d{6}\\.{3}\\d{3}"
)

check_patterns_pct <- function(df) {
  char_cols <- df %>% 
    select(where(is.character)) %>% 
    select(where(~ !all(is.na(.)))) # keep only columns NOT all NA
    
  if (ncol(char_cols) == 0) return(tibble())
  
  purrr::map_dfr(names(char_cols), function(col) {
    values <- char_cols[[col]]
    
    # Calculate match percentages, replace NaN with 0
    matches <- purrr::map_dbl(patterns, function(pat) {
      res <- mean(stringr::str_detect(values, pat), na.rm = TRUE)
      if (is.nan(res)) 0 else res
    })
    
    sample_preview <- paste(utils::head(na.omit(values), 5), collapse = "; ")
    if (sample_preview == "") sample_preview <- NA_character_
    
    tibble(
      column = col,
      sample_preview = sample_preview,
      !!!purrr::set_names(matches, names(patterns))
    )
  }) %>% mutate(source_table = df$source_table[1]) %>% select(source_table, everything())
}

regex_matches <- purrr::map_df(samples_by_table, check_patterns_pct) %>% 
  mutate(phone_combined = pmax(mobile_number_spacing, phone_number_spacing, na.rm = TRUE),
         address_combined = pmax(state_postcode, lots_units, streets, na.rm = TRUE)) %>% 
  select(-mobile_number_spacing, -phone_number_spacing, -state_postcode, -lots_units, -streets)
```

# Joining the two dfs together
```{r}
# Define the list of logical category column names
logical_cols <- c("names", "addresses", "email", "phone_numbers", "financial_details", "business", "gender", "birthday", "potential_pii")

# Categorise columns based on logical match flags
categorised_col_names <- col_name_matches %>%
  mutate(
    colname_match = pmap_chr(
      select(., all_of(logical_cols)), # Pass only category indicator columns into pmap
      ~ {
        vals <- c(...)                 # Logical values for this row
        cols <- logical_cols           # Corresponding category names
        matched <- cols[vals]          # Keep only categories where value is TRUE
        if (length(matched) == 0) NA_character_ else paste(matched, collapse = " | ") # Join multiple matches into one string (i.e. "names | email")
      }
    )
  ) %>% 
  select(table, column_name, data_type, colname_match)

# Identify regex score columns in regex_matches dataframe
regex_score_cols <- names(regex_matches)[4:ncol(regex_matches)]

# Determine the best regex match and score per column
categorised_regex_matches <- regex_matches %>%
  rowwise() %>%
  mutate(
    best_match = if (all(c_across(all_of(regex_score_cols)) == 0)) {
      NA_character_
    } else {
      regex_score_cols[which.max(c_across(all_of(regex_score_cols)))]
    },
    best_match_score = if (all(c_across(all_of(regex_score_cols)) == 0)) {
      NA_real_
    } else {
      max(c_across(all_of(regex_score_cols)))
    }
  ) %>%
  ungroup() %>% 
  select(source_table, column, sample_preview, best_match, best_match_score)

# Combine category-based matches with regex-based matches
final_regex <- categorised_col_names %>% 
  left_join(categorised_regex_matches, by = c("table" = "source_table", "column_name" = "column")) %>% 
  mutate(any_match = !is.na(colname_match) | !is.na(best_match))
```
